using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Net.Sockets;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Net.Security;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.IO;
using System.IO.Compression;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    // runtime mutable current directory for the shell prompt and built-ins
    static string CurrentDirectory = Directory.GetCurrentDirectory();
    static List<string> History = new List<string>();
    static Dictionary<string, Func<string[], Task>> BuiltInCommands = new Dictionary<string, Func<string[], Task>>(StringComparer.OrdinalIgnoreCase);



    static async Task<int> RunExternalAsync(string command)
    {
        var isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
        // ensure our runtime current directory is in sync
        CurrentDirectory = Directory.GetCurrentDirectory();
        var psi = new ProcessStartInfo();
        if (isWindows) { psi.FileName = "cmd.exe"; psi.Arguments = "/c " + command; }
        else { psi.FileName = "/bin/bash"; psi.Arguments = "-lc \"" + command.Replace("\"", "\\\"") + "\""; }
        psi.RedirectStandardOutput = true; psi.RedirectStandardError = true; psi.RedirectStandardInput = true; psi.UseShellExecute = false; psi.CreateNoWindow = true;
        psi.WorkingDirectory = CurrentDirectory;
        using var proc = new Process(); proc.StartInfo = psi;
        var stdoutBuf = new StringBuilder();
        var stderrBuf = new StringBuilder();
        proc.OutputDataReceived += (s, e) => { if (e.Data != null) { stdoutBuf.AppendLine(e.Data); Console.WriteLine(e.Data); } };
        proc.ErrorDataReceived += (s, e) => { if (e.Data != null) { stderrBuf.AppendLine(e.Data); Console.Error.WriteLine(e.Data); } };
        try
        {
            proc.Start(); proc.BeginOutputReadLine(); proc.BeginErrorReadLine();
        }
        catch (System.ComponentModel.Win32Exception)
        {
            // command not found / cannot start -> simulate
            await SimulateCommand(command);
            return -1;
        }
        // forward console input to child process so interactive commands (yum, apt, ssh, etc.) work
        var stdinTask = Task.Run(async () =>
        {
            try
            {
                var writer = proc.StandardInput;
                while (!proc.HasExited)
                {
                    var line = Console.ReadLine();
                    if (line == null) break;
                    try { await writer.WriteLineAsync(line); } catch { break; }
                }
            }


    

            
            catch { }
            finally
            {
                try { proc.StandardInput.Close(); } catch { }
            }
        });

        try { await proc.WaitForExitAsync(); } catch { }
        try { await stdinTask; } catch { }
        var exitCode = proc.ExitCode;
        Console.WriteLine($"[Exit code: {exitCode}]");

        // If command failed because it doesn't exist, stderr usually contains 'not found' or 'not recognized'
        var stderr = stderrBuf.ToString();
        if (exitCode != 0 && (stderr.IndexOf("not found", StringComparison.OrdinalIgnoreCase) >= 0 || stderr.IndexOf("not recognized", StringComparison.OrdinalIgnoreCase) >= 0 || stderr.IndexOf("cannot find", StringComparison.OrdinalIgnoreCase) >= 0 || stderr.IndexOf("No such file", StringComparison.OrdinalIgnoreCase) >= 0))
        {
            await SimulateCommand(command);
        }

        return exitCode;
    }

    static async Task SimulateCommand(string commandLine)
    {
        // Basic simulation so aliases "work" even if host tool is missing.
        var toks = commandLine.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (toks.Length == 0) return;
        var cmd = toks[0];
        var args = toks.Skip(1).ToArray();

        // helper to write simulated success
        void Ok(string msg) => Console.WriteLine(msg);

        // git simulations
        if (cmd.Equals("git", StringComparison.OrdinalIgnoreCase) || cmd.StartsWith("git-", StringComparison.OrdinalIgnoreCase))
        {
            var sub = cmd.Equals("git", StringComparison.OrdinalIgnoreCase) && args.Length>0 ? args[0] : cmd.StartsWith("git-") ? cmd.Substring(4) : "";
            if (sub == "clone" || sub == "clone" && args.Length>0)
            {
                var repo = sub=="clone" && args.Length>0 ? args[1% (args.Length)] : (args.Length>0? args[0] : "repo");
                var name = repo.Split('/').LastOrDefault()?.Replace(".git", "") ?? "repo";
                var outDir = Path.Combine(CurrentDirectory, name);
                try { Directory.CreateDirectory(outDir); File.WriteAllText(Path.Combine(outDir, "README.md"), $"Cloned {repo}"); Ok($"Cloned into '{outDir}'"); } catch { Ok("Simulated clone failed"); }
            }
            else if (sub == "status" || cmd.EndsWith("status", StringComparison.OrdinalIgnoreCase)) Ok("On branch main\nYour branch is up to date.\n\nnothing to commit, working tree clean");
            else if (sub == "pull" || cmd.EndsWith("pull", StringComparison.OrdinalIgnoreCase)) Ok("Simulated: Already up to date.");
            else Ok("Simulated git command: " + commandLine);
            return;
        }

        // package managers
        if (cmd.Equals("npm", StringComparison.OrdinalIgnoreCase) || cmd.Equals("npm-install", StringComparison.OrdinalIgnoreCase) || cmd.Equals("yarn", StringComparison.OrdinalIgnoreCase) || cmd.Equals("pip", StringComparison.OrdinalIgnoreCase) || cmd.StartsWith("pip-"))
        {
            if (cmd.Contains("npm") || cmd.Contains("yarn"))
            {
                var nm = Path.Combine(CurrentDirectory, "node_modules");
                try { Directory.CreateDirectory(nm); File.WriteAllText(Path.Combine(CurrentDirectory, "package-lock.json"), "{}"); Ok("Installed packages (simulated)"); } catch { Ok("Simulated install failed"); }
            }
            else
            {
                Ok("Simulated pip action: " + string.Join(' ', args));
            }
            return;
        }

        // docker simulation
        if (cmd.Equals("docker", StringComparison.OrdinalIgnoreCase) || cmd.StartsWith("docker-"))
        {
            if (commandLine.IndexOf("ps", StringComparison.OrdinalIgnoreCase) >= 0) Ok("CONTAINER ID\tIMAGE\tSTATUS\n");
            else if (commandLine.IndexOf("images", StringComparison.OrdinalIgnoreCase) >= 0) Ok("REPOSITORY\tTAG\tIMAGE ID\tSIZE\n");
            else Ok("Simulated docker: " + commandLine);
            return;
        }

        // kubectl simulation
        if (cmd.Equals("kubectl", StringComparison.OrdinalIgnoreCase) || cmd.StartsWith("kubectl-"))
        {
            Ok("No resources found in default namespace (simulated).");
            return;
        }

        // yum/apt/dnf simulation: pretend package installed
        if (cmd.Equals("yum", StringComparison.OrdinalIgnoreCase) || cmd.Equals("apt", StringComparison.OrdinalIgnoreCase) || cmd.Equals("dnf", StringComparison.OrdinalIgnoreCase) || cmd.Equals("pacman", StringComparison.OrdinalIgnoreCase))
        {
            if (args.Length > 0 && (args[0].Equals("install", StringComparison.OrdinalIgnoreCase) || args[0].Equals("update", StringComparison.OrdinalIgnoreCase)))
            {
                var db = Path.Combine(CurrentDirectory, ".ter_pkg_db");
                try { File.AppendAllLines(db, new[]{cmd + " " + string.Join(' ', args)}); Ok("Package operation simulated: " + string.Join(' ', args)); } catch { Ok("Simulated package operation failed"); }
                return;
            }
            Ok("Simulated package manager: " + commandLine);
            return;
        }

        // ssh simulation
        if (cmd.Equals("ssh", StringComparison.OrdinalIgnoreCase) || cmd.Equals("scp", StringComparison.OrdinalIgnoreCase))
        {
            Ok("Simulated SSH connection to " + (args.Length>0? args[0] : "host"));
            return;
        }

        // default generic simulation
        Ok("Simulated: " + commandLine);
        await Task.CompletedTask;
    }

    static void InitializeBuiltIns()
    {
        // Lightweight internal commands
        BuiltInCommands["help"] = async args =>
        {
            Console.WriteLine("Built-in commands:");
            foreach (var k in BuiltInCommands.Keys.OrderBy(k => k)) Console.WriteLine("  " + k);
            await Task.CompletedTask;
        };

        // corscheck <url> - check Access-Control-Allow-Origin header
        BuiltInCommands["corscheck"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: corscheck <url>"); await Task.CompletedTask; return; }
            try
            {
                var url = args[0]; if (!url.StartsWith("http", StringComparison.OrdinalIgnoreCase)) url = "http://" + url;
                using var http = new HttpClient(); using var resp = await http.GetAsync(url);
                Console.WriteLine($"Status: {(int)resp.StatusCode} {resp.ReasonPhrase}");
                if (resp.Headers.TryGetValues("Access-Control-Allow-Origin", out var origins)) Console.WriteLine("Access-Control-Allow-Origin: " + string.Join(", ", origins)); else Console.WriteLine("Access-Control-Allow-Origin: (missing)");
                if (resp.Headers.TryGetValues("Access-Control-Allow-Credentials", out var creds)) Console.WriteLine("Access-Control-Allow-Credentials: " + string.Join(", ", creds));
                // quick advice
                if (resp.Headers.TryGetValues("Access-Control-Allow-Origin", out origins) && origins.Any(o => o.Trim() == "*")) Console.WriteLine("WARNING: CORS Allow-Origin is wildcard '*'; this may be unsafe for credentialed endpoints.");
            }
            catch (Exception ex) { Console.WriteLine("corscheck error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // serverinfo <url> - show Server and other fingerprint headers
        BuiltInCommands["serverinfo"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: serverinfo <url>"); await Task.CompletedTask; return; }
            try
            {
                var url = args[0]; if (!url.StartsWith("http", StringComparison.OrdinalIgnoreCase)) url = "http://" + url;
                using var http = new HttpClient(); using var resp = await http.GetAsync(url);
                Console.WriteLine($"Status: {(int)resp.StatusCode} {resp.ReasonPhrase}");
                if (resp.Headers.TryGetValues("Server", out var s)) Console.WriteLine("Server: " + string.Join(", ", s));
                if (resp.Headers.TryGetValues("X-Powered-By", out var p)) Console.WriteLine("X-Powered-By: " + string.Join(", ", p));
                if (resp.Headers.TryGetValues("Via", out var v)) Console.WriteLine("Via: " + string.Join(", ", v));
            }
            catch (Exception ex) { Console.WriteLine("serverinfo error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // password store: savepass/getpass/listpass/delpass - stores secrets encrypted locally
        string PassStorePath() => Path.Combine(CurrentDirectory, ".ter_passstore");

        byte[] ProtectData(byte[] plain)
        {
            // Use AES with key derived from user+machine. This avoids platform-specific DPAPI types
            // that may not be available at compile time on all frameworks.
            using var sha = SHA256.Create();
            var key = sha.ComputeHash(Encoding.UTF8.GetBytes(Environment.UserName + "@" + Environment.MachineName + "::ter"));
            using var aes = Aes.Create();
            aes.Key = key;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            aes.GenerateIV();
            using var ms = new MemoryStream();
            ms.Write(aes.IV, 0, aes.IV.Length);
            using (var cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(plain, 0, plain.Length);
                cs.FlushFinalBlock();
            }
            return ms.ToArray();
        }

        byte[] UnprotectData(byte[] blob)
        {
            using var sha = SHA256.Create();
            var key = sha.ComputeHash(Encoding.UTF8.GetBytes(Environment.UserName + "@" + Environment.MachineName + "::ter"));
            using var aes = Aes.Create();
            aes.Key = key;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            // IV is prepended
            using var ms = new MemoryStream(blob);
            var iv = new byte[16];
            var read = ms.Read(iv, 0, iv.Length);
            if (read != iv.Length) throw new Exception("Invalid blob");
            aes.IV = iv;
            using var cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Read);
            using var outMs = new MemoryStream();
            cs.CopyTo(outMs);
            return outMs.ToArray();
        }

        BuiltInCommands["savepass"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: savepass <name> <password>"); await Task.CompletedTask; return; }
            try
            {
                var name = args[0]; var pw = args[1]; var path = PassStorePath(); var store = new Dictionary<string, string>();
                if (File.Exists(path)) store = JsonSerializer.Deserialize<Dictionary<string, string>>(await File.ReadAllTextAsync(path)) ?? new Dictionary<string, string>();
                var blob = ProtectData(Encoding.UTF8.GetBytes(pw)); store[name] = Convert.ToBase64String(blob);
                await File.WriteAllTextAsync(path, JsonSerializer.Serialize(store)); Console.WriteLine("Saved.");
            }
            catch (Exception ex) { Console.WriteLine("savepass error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["getpass"] = async args =>
        {
            if (args.Length < 1) { Console.WriteLine("Usage: getpass <name>"); await Task.CompletedTask; return; }
            try
            {
                var name = args[0]; var path = PassStorePath(); if (!File.Exists(path)) { Console.WriteLine("No store found."); await Task.CompletedTask; return; }
                var store = JsonSerializer.Deserialize<Dictionary<string, string>>(await File.ReadAllTextAsync(path)) ?? new Dictionary<string, string>();
                if (!store.TryGetValue(name, out var b64)) { Console.WriteLine("Not found: " + name); await Task.CompletedTask; return; }
                var blob = Convert.FromBase64String(b64); var plain = UnprotectData(blob); Console.WriteLine(Encoding.UTF8.GetString(plain));
            }
            catch (Exception ex) { Console.WriteLine("getpass error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["listpass"] = async args =>
        {
            try
            {
                var path = PassStorePath(); if (!File.Exists(path)) { Console.WriteLine("No store found."); await Task.CompletedTask; return; }
                var store = JsonSerializer.Deserialize<Dictionary<string, string>>(await File.ReadAllTextAsync(path)) ?? new Dictionary<string, string>();
                foreach (var k in store.Keys) Console.WriteLine(k);
            }
            catch (Exception ex) { Console.WriteLine("listpass error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["delpass"] = async args =>
        {
            if (args.Length < 1) { Console.WriteLine("Usage: delpass <name>"); await Task.CompletedTask; return; }
            try
            {
                var name = args[0]; var path = PassStorePath(); if (!File.Exists(path)) { Console.WriteLine("No store found."); await Task.CompletedTask; return; }
                var store = JsonSerializer.Deserialize<Dictionary<string, string>>(await File.ReadAllTextAsync(path)) ?? new Dictionary<string, string>();
                if (store.Remove(name)) { await File.WriteAllTextAsync(path, JsonSerializer.Serialize(store)); Console.WriteLine("Removed."); } else Console.WriteLine("Not found.");
            }
            catch (Exception ex) { Console.WriteLine("delpass error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // httpget <url> [-o outFile] - download URL and print status + preview
        BuiltInCommands["httpget"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: httpget <url> [-o outFile]"); await Task.CompletedTask; return; }
            try
            {
                var url = args[0];
                if (!url.StartsWith("http://", StringComparison.OrdinalIgnoreCase) && !url.StartsWith("https://", StringComparison.OrdinalIgnoreCase)) url = "http://" + url;
                string outFile = null;
                for (int i = 1; i < args.Length; i++) if (args[i] == "-o" && i + 1 < args.Length) { outFile = args[i + 1]; i++; }

                using var http = new HttpClient();
                using var resp = await http.GetAsync(url);
                Console.WriteLine($"Status: {(int)resp.StatusCode} {resp.ReasonPhrase}");
                foreach (var h in resp.Headers) Console.WriteLine($"{h.Key}: {string.Join(", ", h.Value)}");
                var body = await resp.Content.ReadAsStringAsync();
                var preview = body.Length > 1000 ? body.Substring(0, 1000) + "..." : body;
                Console.WriteLine("--- Begin body preview ---");
                Console.WriteLine(preview);
                Console.WriteLine("--- End body preview ---");
                if (!string.IsNullOrEmpty(outFile))
                {
                    if (!Path.IsPathRooted(outFile)) outFile = Path.Combine(CurrentDirectory, outFile);
                    await File.WriteAllTextAsync(outFile, body);
                    Console.WriteLine("Saved to " + outFile);
                }
            }
            catch (Exception ex) { Console.WriteLine("httpget error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // security-headers <url> - fetch headers and evaluate common security headers
        BuiltInCommands["security-headers"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: security-headers <url>"); await Task.CompletedTask; return; }
            try
            {
                var url = args[0]; if (!url.StartsWith("http://", StringComparison.OrdinalIgnoreCase) && !url.StartsWith("https://", StringComparison.OrdinalIgnoreCase)) url = "http://" + url;
                using var http = new HttpClient(); using var resp = await http.GetAsync(url);
                Console.WriteLine($"Status: {(int)resp.StatusCode} {resp.ReasonPhrase}");
                var hdrs = resp.Headers.Concat(resp.Content.Headers).ToDictionary(h => h.Key, h => string.Join(", ", h.Value));

                void Check(string name, Func<string, bool> ok, string goodMsg, string warnMsg)
                {
                    if (hdrs.TryGetValue(name, out var val)) Console.WriteLine($"{name}: {val} - {goodMsg}"); else Console.WriteLine($"{name}: MISSING - {warnMsg}");
                }

                Check("Strict-Transport-Security", v => !string.IsNullOrEmpty(v), "HSTS present", "Recommend HSTS for HTTPS sites");
                Check("Content-Security-Policy", v => !string.IsNullOrEmpty(v), "CSP present", "Consider adding CSP to mitigate XSS");
                Check("X-Frame-Options", v => !string.IsNullOrEmpty(v), "X-Frame-Options present", "Consider preventing clickjacking");
                Check("Referrer-Policy", v => !string.IsNullOrEmpty(v), "Referrer-Policy present", "Consider setting a referrer policy");
                Check("X-Content-Type-Options", v => v.Equals("nosniff", StringComparison.OrdinalIgnoreCase), "X-Content-Type-Options=nosniff", "Consider enabling nosniff");
                Check("Permissions-Policy", v => !string.IsNullOrEmpty(v), "Permissions-Policy present", "Consider restricting powerful features");
            }
            catch (Exception ex) { Console.WriteLine("security-headers error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // robots <url> - fetch robots.txt
        BuiltInCommands["robots"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: robots <site>"); await Task.CompletedTask; return; }
            try
            {
                var site = args[0]; if (!site.StartsWith("http", StringComparison.OrdinalIgnoreCase)) site = "http://" + site;
                var uri = new Uri(site);
                var robotsUrl = uri.Scheme + "://" + uri.Host + "/robots.txt";
                using var http = new HttpClient(); var resp = await http.GetAsync(robotsUrl);
                if (!resp.IsSuccessStatusCode) { Console.WriteLine("robots.txt not found or inaccessible: " + resp.StatusCode); await Task.CompletedTask; return; }
                var txt = await resp.Content.ReadAsStringAsync(); Console.WriteLine(txt);
            }
            catch (Exception ex) { Console.WriteLine("robots error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // sitemap <url> - fetch sitemap.xml and print a short view
        BuiltInCommands["sitemap"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: sitemap <site>"); await Task.CompletedTask; return; }
            try
            {
                var site = args[0]; if (!site.StartsWith("http", StringComparison.OrdinalIgnoreCase)) site = "http://" + site;
                var uri = new Uri(site);
                var url = uri.Scheme + "://" + uri.Host + "/sitemap.xml";
                using var http = new HttpClient(); var resp = await http.GetAsync(url);
                if (!resp.IsSuccessStatusCode) { Console.WriteLine("sitemap.xml not found: " + resp.StatusCode); await Task.CompletedTask; return; }
                var xml = await resp.Content.ReadAsStringAsync();
                var lines = xml.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).Take(50);
                foreach (var l in lines) Console.WriteLine(l.Trim());
            }
            catch (Exception ex) { Console.WriteLine("sitemap error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // whois <domain> - runs external whois via run-external (prompts for confirmation)
        BuiltInCommands["whois"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: whois <domain>"); await Task.CompletedTask; return; }
            if (BuiltInCommands.TryGetValue("run-external", out var runExt))
            {
                try { await runExt(new[] { "whois", args[0] }); } catch (Exception ex) { Console.WriteLine("whois error: " + ex.Message); }
            }
            else Console.WriteLine("whois helper unavailable");
            await Task.CompletedTask;
        };

        // sslcheck <host[:port]> - enhanced TLS checks (passive)
        BuiltInCommands["sslcheck"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: sslcheck <host[:port]>"); await Task.CompletedTask; return; }
            try
            {
                var input = args[0]; string host; int port = 443;
                if (input.IndexOf(':') > 0 && !input.Contains('/')) { var parts = input.Split(':'); host = parts[0]; int.TryParse(parts[1], out port); }
                else if (input.StartsWith("http://", StringComparison.OrdinalIgnoreCase) || input.StartsWith("https://", StringComparison.OrdinalIgnoreCase)) { var u = new Uri(input); host = u.Host; port = u.Port; if (port == -1) port = u.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ? 443 : 80; }
                else host = input;

                using var tcp = new TcpClient(); await tcp.ConnectAsync(host, port);
                using var stream = tcp.GetStream(); using var ssl = new SslStream(stream, false, (sender, cert, chain, errs) => true);
                await ssl.AuthenticateAsClientAsync(host);
                var cert = ssl.RemoteCertificate as X509Certificate2 ?? new X509Certificate2(ssl.RemoteCertificate);
                Console.WriteLine($"Subject: {cert.Subject}"); Console.WriteLine($"Issuer: {cert.Issuer}");
                Console.WriteLine($"NotBefore: {cert.NotBefore}"); Console.WriteLine($"NotAfter: {cert.NotAfter}");
                var days = (cert.NotAfter - DateTime.UtcNow).TotalDays; Console.WriteLine($"Expires in: {Math.Round(days,1)} days");
                if (days < 7) Console.WriteLine("WARNING: Certificate expires within 7 days");
            }
            catch (Exception ex) { Console.WriteLine("sslcheck error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // groq [--key <key>] [message] - send a single chat message to Groq API (uses GROQ_API_KEY, AI_API_KEY, or .ai_key if present)
        BuiltInCommands["groq"] = async args =>
        {
            try
            {
                var argList = args.ToList();
                string key = null;
                if (argList.Count >= 2 && argList[0] == "--key")
                {
                    key = argList[1];
                    argList.RemoveRange(0, 2);
                }
                var localKeyPath = Path.Combine(CurrentDirectory, ".ai_key");
                if (string.IsNullOrEmpty(key) && File.Exists(localKeyPath)) key = await File.ReadAllTextAsync(localKeyPath);
                if (string.IsNullOrEmpty(key)) key = Environment.GetEnvironmentVariable("GROQ_API_KEY") ?? Environment.GetEnvironmentVariable("AI_API_KEY");
                if (string.IsNullOrEmpty(key)) { Console.WriteLine("No API key found. Use --key or set GROQ_API_KEY/AI_API_KEY or use ai-setkey."); await Task.CompletedTask; return; }

                var message = argList.Count > 0 ? string.Join(' ', argList) : "Hello!";

                using var client = new HttpClient();
                client.DefaultRequestHeaders.Add("Authorization", "Bearer " + key);

                var body = new
                {
                    model = "llama3-70b-8192",
                    messages = new[] { new { role = "user", content = message } }
                };

                var json = JsonSerializer.Serialize(body);
                using var content = new StringContent(json, Encoding.UTF8, "application/json");
                var response = await client.PostAsync("https://api.groq.com/openai/v1/chat/completions", content);
                var result = await response.Content.ReadAsStringAsync();
                Console.WriteLine(result);
            }
            catch (Exception ex)
            {
                Console.WriteLine("groq error: " + ex.Message);
            }
            await Task.CompletedTask;
        };

        // ai-setkey <key> - save API key to a local hidden file in the current directory
        BuiltInCommands["ai-setkey"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: ai-setkey <key>"); await Task.CompletedTask; return; }
            try
            {
                var key = args[0];
                var path = Path.Combine(CurrentDirectory, ".ai_key");
                await File.WriteAllTextAsync(path, key);
                try { if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) { var fi = new FileInfo(path); fi.Attributes |= FileAttributes.Hidden; } } catch { }
                Console.WriteLine("Saved API key to " + path);
            }
            catch (Exception ex) { Console.WriteLine("ai-setkey error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // ai-clearkey - remove local saved key
        BuiltInCommands["ai-clearkey"] = async args =>
        {
            try
            {
                var path = Path.Combine(CurrentDirectory, ".ai_key");
                if (File.Exists(path)) { File.Delete(path); Console.WriteLine("Removed local key: " + path); }
                else Console.WriteLine("No local key file found.");
            }
            catch (Exception ex) { Console.WriteLine("ai-clearkey error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // ai [--key <key>] [initial prompt]
        // If called with no prompt, enters interactive conversation mode. Conversation context is preserved during session.
        BuiltInCommands["ai"] = async args =>
        {
            try
            {
                var argList = args.ToList();
                string key = null;
                if (argList.Count >= 2 && argList[0] == "--key")
                {
                    key = argList[1];
                    argList.RemoveRange(0, 2);
                }
                var localKeyPath = Path.Combine(CurrentDirectory, ".ai_key");
                if (string.IsNullOrEmpty(key) && File.Exists(localKeyPath)) key = await File.ReadAllTextAsync(localKeyPath);
                if (string.IsNullOrEmpty(key)) key = Environment.GetEnvironmentVariable("AI_API_KEY");
                if (string.IsNullOrEmpty(key)) { Console.WriteLine("No API key found. Set AI_API_KEY, use ai-setkey, or pass --key."); await Task.CompletedTask; return; }

                var apiUrl = Environment.GetEnvironmentVariable("AI_API_URL") ?? "https://api.openai.com/v1/chat/completions";

                // helper to send messages list and return assistant content
                async Task<string> SendMessagesAsync(List<Dictionary<string, string>> messages)
                {
                    var payload = new Dictionary<string, object>
                    {
                        ["model"] = "gpt-3.5-turbo",
                        ["messages"] = messages,
                        ["max_tokens"] = 512
                    };
                    var json = JsonSerializer.Serialize(payload);
                    using var http = new HttpClient();
                    http.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", key);
                    http.DefaultRequestHeaders.UserAgent.ParseAdd("ter-ai/1.0");
                    using var content = new StringContent(json, Encoding.UTF8, "application/json");
                    using var resp = await http.PostAsync(apiUrl, content);
                    var respText = await resp.Content.ReadAsStringAsync();
                    if (!resp.IsSuccessStatusCode) throw new Exception($"AI request failed: {(int)resp.StatusCode} {resp.ReasonPhrase}\n{respText}");
                    using var doc = JsonDocument.Parse(respText);
                    if (doc.RootElement.TryGetProperty("choices", out var choices) && choices.GetArrayLength() > 0)
                    {
                        var first = choices[0];
                        if (first.TryGetProperty("message", out var msg) && msg.TryGetProperty("content", out var contentEl)) return contentEl.GetString() ?? string.Empty;
                        if (first.TryGetProperty("text", out var textEl)) return textEl.GetString() ?? string.Empty;
                    }
                    return respText;
                }

                // If initial prompt provided, do single-shot with that prompt; otherwise interactive loop
                if (argList.Count > 0)
                {
                    var prompt = string.Join(' ', argList);
                    var messages = new List<Dictionary<string, string>> { new() { ["role"] = "user", ["content"] = prompt } };
                    try { var reply = await SendMessagesAsync(messages); Console.WriteLine(reply); }
                    catch (Exception ex) { Console.WriteLine("ai error: " + ex.Message); }
                    await Task.CompletedTask; return;
                }

                // Interactive conversation
                Console.WriteLine("Entering AI conversation mode. Type '/exit' to quit, '/reset' to clear context.");
                var convo = new List<Dictionary<string, string>>();
                while (true)
                {
                    Console.Write("you> ");
                    var line = Console.ReadLine();
                    if (line == null) break;
                    var t = line.Trim();
                    if (t.Equals("/exit", StringComparison.OrdinalIgnoreCase) || t.Equals("/quit", StringComparison.OrdinalIgnoreCase)) break;
                    if (t.Equals("/reset", StringComparison.OrdinalIgnoreCase)) { convo.Clear(); Console.WriteLine("Context cleared."); continue; }
                    if (string.IsNullOrWhiteSpace(t)) continue;
                    convo.Add(new Dictionary<string, string> { ["role"] = "user", ["content"] = t });
                    try
                    {
                        var reply = await SendMessagesAsync(convo);
                        // append assistant reply to context
                        convo.Add(new Dictionary<string, string> { ["role"] = "assistant", ["content"] = reply });
                        Console.WriteLine("ai> " + reply.Replace("\n", "\nai> "));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("ai error: " + ex.Message);
                    }
                }
            }
            catch (Exception ex) { Console.WriteLine("ai error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // run-external <tool> <args...> - prompt then run an external tool if present on PATH
        BuiltInCommands["run-external"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: run-external <tool> [args]"); await Task.CompletedTask; return; }
            var tool = args[0]; var toolArgs = args.Length > 1 ? string.Join(' ', args.Skip(1)) : string.Empty;

            bool ToolExists(string name)
            {
                if (Path.IsPathRooted(name)) return File.Exists(name);
                var paths = (Environment.GetEnvironmentVariable("PATH") ?? "").Split(Path.PathSeparator, StringSplitOptions.RemoveEmptyEntries);
                var exts = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
                    ? (Environment.GetEnvironmentVariable("PATHEXT") ?? ".EXE;.CMD;.BAT;.COM").Split(';', StringSplitOptions.RemoveEmptyEntries)
                    : new[] { "" };
                foreach (var p in paths)
                {
                    try
                    {
                        foreach (var ext in exts)
                        {
                            var candidate = Path.Combine(p, name + ext);
                            if (File.Exists(candidate)) return true;
                        }
                    }
                    catch { }
                }
                return false;
            }

            var exists = ToolExists(tool);
            if (!exists)
            {
                Console.WriteLine($"Tool not found on PATH: {tool}");
                await Task.CompletedTask; return;
            }

            Console.WriteLine($"About to run: {tool} {toolArgs}");
            Console.Write("Confirm execution? (y/N): ");
            var yn = Console.ReadLine();
            if (string.IsNullOrEmpty(yn) || !yn.Trim().StartsWith("y", StringComparison.OrdinalIgnoreCase)) { Console.WriteLine("Aborted."); await Task.CompletedTask; return; }

            try
            {
                var cmd = tool + (string.IsNullOrEmpty(toolArgs) ? string.Empty : " " + toolArgs);
                await RunExternalAsync(cmd);
            }
            catch (Exception ex) { Console.WriteLine("run-external error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // passcheck <password> - estimate password entropy and give improvements
        BuiltInCommands["passcheck"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: passcheck <password>"); await Task.CompletedTask; return; }
            var pw = args[0];
            int charset = 0;
            if (pw.Any(c => char.IsLower(c))) charset += 26;
            if (pw.Any(c => char.IsUpper(c))) charset += 26;
            if (pw.Any(c => char.IsDigit(c))) charset += 10;
            if (pw.Any(c => !char.IsLetterOrDigit(c))) charset += 32; // approximate symbols
            if (charset == 0) charset = 1;
            double entropy = pw.Length * Math.Log(charset, 2);
            Console.WriteLine($"Length: {pw.Length}");
            Console.WriteLine($"Charset size (approx): {charset}");
            Console.WriteLine($"Estimated entropy: {Math.Round(entropy, 2)} bits");
            if (entropy < 28) Console.WriteLine("Very weak: use a longer password or passphrase.");
            else if (entropy < 50) Console.WriteLine("Weak: increase length and include more character classes.");
            else if (entropy < 80) Console.WriteLine("Reasonable for low-value accounts; prefer stronger for important accounts.");
            else Console.WriteLine("Strong password.");
            Console.WriteLine("Suggestions: use a passphrase (4+ random words), enable MFA, and avoid reuse.");
            await Task.CompletedTask;
        };

        // breachcheck <password> <file> - check password against local breach list (exact match)
        BuiltInCommands["breachcheck"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: breachcheck <password> <breach-list-file>"); await Task.CompletedTask; return; }
            var pw = args[0];
            var path = args[1]; if (!Path.IsPathRooted(path)) path = Path.Combine(CurrentDirectory, path);
            if (!File.Exists(path)) { Console.WriteLine("Breach list file not found: " + path); await Task.CompletedTask; return; }
            try
            {
                bool found = false;
                using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read);
                using var sr = new StreamReader(fs);
                string line;
                while ((line = await sr.ReadLineAsync()) != null)
                {
                    if (line.Trim() == pw) { found = true; break; }
                }
                Console.WriteLine(found ? "Password FOUND in breach list (do NOT use)." : "Password not found in provided list.");
            }
            catch (Exception ex) { Console.WriteLine("breachcheck error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // hash <alg> <text> - compute common hashes (md5, sha1, sha256)
        BuiltInCommands["hash"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: hash <md5|sha1|sha256> <text>"); await Task.CompletedTask; return; }
            var alg = args[0].ToLowerInvariant(); var text = string.Join(' ', args.Skip(1));
            try
            {
                byte[] data = Encoding.UTF8.GetBytes(text);
                byte[] digest = null;
                if (alg == "md5") using (var h = MD5.Create()) { digest = h.ComputeHash(data); }
                else if (alg == "sha1") using (var h = SHA1.Create()) { digest = h.ComputeHash(data); }
                else using (var h = SHA256.Create()) { digest = h.ComputeHash(data); }
                Console.WriteLine(BitConverter.ToString(digest).Replace("-", "").ToLowerInvariant());
            }
            catch (Exception ex) { Console.WriteLine("hash error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // pwpolicy - print a recommended password policy
        BuiltInCommands["pwpolicy"] = async args =>
        {
            Console.WriteLine("Recommended password policy:");
            Console.WriteLine(" - Minimum length: 12 characters (prefer 16+ for high value accounts)");
            Console.WriteLine(" - Use passphrases (4 random words) or mixed character sets");
            Console.WriteLine(" - Disallow common passwords and leaked passwords (check at creation)");
            Console.WriteLine(" - Enforce multi-factor authentication for privileged accounts");
            Console.WriteLine(" - Rotate only when compromise suspected; prefer MFA + strong passwords");
            await Task.CompletedTask;
        };

        // genpass [length] - generate a strong random password
        BuiltInCommands["genpass"] = async args =>
        {
            int length = 16;
            if (args.Length > 0 && int.TryParse(args[0], out var l)) length = Math.Max(4, Math.Min(256, l));
            const string lowers = "abcdefghijklmnopqrstuvwxyz";
            const string uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const string digits = "0123456789";
            const string symbols = "!@#$%^&*()-_=+[]{};:,.<>?/|\\";
            var all = (lowers + uppers + digits + symbols).ToCharArray();
            var pwd = new char[length];
            try
            {
                using var rng = RandomNumberGenerator.Create();
                var buf = new byte[length];
                rng.GetBytes(buf);
                for (int i = 0; i < length; i++) pwd[i] = all[buf[i] % all.Length];
                var result = new string(pwd);
                Console.WriteLine(result);
            }
            catch (Exception ex) { Console.WriteLine("genpass error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // netinfo - list network interfaces and addresses
        BuiltInCommands["netinfo"] = async args =>
        {
            try
            {
                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    Console.WriteLine($"{ni.Name} - {ni.NetworkInterfaceType} - {ni.OperationalStatus}");
                    var props = ni.GetIPProperties();
                    foreach (var addr in props.UnicastAddresses)
                        Console.WriteLine($"  {addr.Address}");
                }
            }
            catch (Exception ex) { Console.WriteLine("netinfo error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // dns <host> - resolve host to IPs
        BuiltInCommands["dns"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: dns <host>"); await Task.CompletedTask; return; }
            try
            {
                var host = args[0];
                var addrs = await Dns.GetHostAddressesAsync(host);
                foreach (var a in addrs) Console.WriteLine(a);
            }
            catch (Exception ex) { Console.WriteLine("dns error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // httphead <url> - fetch HTTP headers
        BuiltInCommands["httphead"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: httphead <url|host[:port]>"); await Task.CompletedTask; return; }
            try
            {
                // accept raw host or full URL; if host provided, assume http://
                string input = args[0];
                Uri uri;
                if (input.StartsWith("http://", StringComparison.OrdinalIgnoreCase) || input.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                {
                    uri = new Uri(input);
                }
                else
                {
                    // if host:port provided, build a http:// URI
                    if (input.IndexOf(':') >= 0) uri = new Uri("http://" + input);
                    else uri = new Uri("http://" + input);
                }

                using var http = new HttpClient();
                using var req = new HttpRequestMessage(HttpMethod.Head, uri);
                using var resp = await http.SendAsync(req);
                Console.WriteLine($"Status: {(int)resp.StatusCode} {resp.ReasonPhrase}");
                foreach (var h in resp.Headers) Console.WriteLine($"{h.Key}: {string.Join(", ", h.Value)}");
                foreach (var h in resp.Content.Headers) Console.WriteLine($"{h.Key}: {string.Join(", ", h.Value)}");
            }
            catch (Exception ex) { Console.WriteLine("httphead error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // tlsinfo <host> [port] - retrieve TLS certificate info (connects to host:port)
        BuiltInCommands["tlsinfo"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: tlsinfo <host|url> [port]"); await Task.CompletedTask; return; }
            try
            {
                string input = args[0];
                string host; int port = -1;
                if (input.StartsWith("http://", StringComparison.OrdinalIgnoreCase) || input.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                {
                    var u = new Uri(input);
                    host = u.Host; port = u.Port;
                    if (port == -1) port = u.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ? 443 : 80;
                }
                else if (input.IndexOf(':') > 0 && IPAddress.TryParse(input.Split(':')[0], out _))
                {
                    var parts = input.Split(':'); host = parts[0]; int.TryParse(parts[1], out port);
                }
                else
                {
                    host = input; port = 443;
                }
                if (args.Length > 1) int.TryParse(args[1], out port);

                using var tcp = new TcpClient();
                await tcp.ConnectAsync(host, port);
                using var stream = tcp.GetStream();
                using var ssl = new SslStream(stream, false, (sender, cert, chain, errs) => true);
                await ssl.AuthenticateAsClientAsync(host);
                var cert = ssl.RemoteCertificate as X509Certificate2 ?? new X509Certificate2(ssl.RemoteCertificate);
                Console.WriteLine($"Subject: {cert.Subject}");
                Console.WriteLine($"Issuer: {cert.Issuer}");
                Console.WriteLine($"Thumbprint: {cert.Thumbprint}");
                Console.WriteLine($"NotBefore: {cert.NotBefore}");
                Console.WriteLine($"NotAfter: {cert.NotAfter}");
                Console.WriteLine($"SignatureAlgorithm: {cert.SignatureAlgorithm.FriendlyName}");
            }
            catch (Exception ex) { Console.WriteLine("tlsinfo error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // scan <host|local> [ports] - improved scanner: resolves host, shows IP(s), reverse dns, attempts banner grabs.
        // If target is 'local', 'in', 'lan', 'network' or omitted the command will discover other hosts on the local /24 and scan them.
        BuiltInCommands["scan"] = async args =>
        {
            try
            {
                // support flag --allow-external to permit scanning non-private/public addresses (must be explicit)
                var argList = args.ToList();
                bool allowExternal = false;
                for (int i = argList.Count - 1; i >= 0; i--) if (argList[i].Equals("--allow-external", StringComparison.OrdinalIgnoreCase)) { allowExternal = true; argList.RemoveAt(i); }

                string targetArg = argList.Count > 0 ? argList[0] : "local";
                string portsArg = argList.Count > 1 ? argList[1] : "22,80,443,3389,3306,8080,53,21,25,445";

                var doSubnetScan = new[] { "local", "in", "lan", "network", "subnet", "" };
                if (doSubnetScan.Contains(targetArg.ToLowerInvariant()))
                {
                    // find local IPv4 and IPv6 addresses
                    string localV4 = null;
                    var localV6 = new List<IPAddress>();
                    foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                    {
                        if (ni.OperationalStatus != OperationalStatus.Up) continue;
                        foreach (var ua in ni.GetIPProperties().UnicastAddresses)
                        {
                            if (ua.Address.IsIPv4MappedToIPv6) continue;
                            if (ua.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork && !IPAddress.IsLoopback(ua.Address)) { localV4 ??= ua.Address.ToString(); }
                            if (ua.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6 && !IPAddress.IsLoopback(ua.Address)) localV6.Add(ua.Address);
                        }
                        if (localV4 != null || localV6.Count > 0) break;
                    }
                    if (localV4 == null && localV6.Count == 0) { Console.WriteLine("No local IP addresses found."); await Task.CompletedTask; return; }

                    if (localV4 != null)
                    {
                        var parts = localV4.Split('.'); var prefix = string.Join('.', parts.Take(3)) + ".";
                        int max = 64; // limit sweep size
                        if (argList.Count > 1 && int.TryParse(argList[1], out var m)) max = Math.Min(254, Math.Max(4, m));
                        Console.WriteLine($"Scanning local IPv4 subnet {prefix}1-{prefix}{max} (ping sweep + port scan)...");

                        // ping sweep (IPv4)
                        var up = new List<string>();
                        var pingSem = new System.Threading.SemaphoreSlim(100);
                        var pingTasks = new List<Task>();
                        for (int i = 1; i <= max; i++)
                        {
                            var ip = prefix + i;
                            await pingSem.WaitAsync();
                            pingTasks.Add(Task.Run(async () =>
                            {
                                try { using var p = new Ping(); var r = await p.SendPingAsync(ip, 300); if (r.Status == IPStatus.Success) lock (up) { up.Add(ip); } }
                                catch { }
                                finally { pingSem.Release(); }
                            }));
                        }
                        await Task.WhenAll(pingTasks);
                        up = up.OrderBy(x => x).ToList();
                        Console.WriteLine($"IPv4 hosts up: {string.Join(',', up)}");

                        // parse portsArg
                        var ports = new List<int>();
                        foreach (var token in portsArg.Split(',', StringSplitOptions.RemoveEmptyEntries))
                        {
                            var t = token.Trim();
                            if (t.Contains('-'))
                            {
                                var p = t.Split('-', 2);
                                if (int.TryParse(p[0], out var a) && int.TryParse(p[1], out var b)) { for (int j = Math.Min(a,b); j <= Math.Max(a,b); j++) ports.Add(j); }
                            }
                            else if (int.TryParse(t, out var p)) ports.Add(p);
                        }
                        ports = ports.Distinct().Where(p => p >= 1 && p <= 65535).OrderBy(p => p).ToList();
                        if (ports.Count == 0) { Console.WriteLine("No ports to scan."); await Task.CompletedTask; return; }

                        var wellKnown = new Dictionary<int,string> { [22] = "ssh", [80] = "http", [443] = "https", [3389] = "rdp", [3306] = "mysql", [8080] = "http-alt", [53] = "dns", [21] = "ftp", [25] = "smtp", [445] = "microsoft-ds" };

                        // scan each up host, limited parallelism
                        var hostSem = new System.Threading.SemaphoreSlim(10);
                        var hostTasks = new List<Task>();
                        foreach (var h in up)
                        {
                            await hostSem.WaitAsync();
                            hostTasks.Add(Task.Run(async () =>
                            {
                                try
                                {
                                    Console.WriteLine($"\nHost: {h}");
                                    foreach (var port in ports)
                                    {
                                        try
                                        {
                                            using var tc = new TcpClient();
                                            var conn = tc.ConnectAsync(h, port);
                                            var comp = await Task.WhenAny(conn, Task.Delay(500));
                                            if (comp == conn && tc.Connected)
                                            {
                                                Console.Write($"  {port}: open"); if (wellKnown.TryGetValue(port, out var svc)) Console.Write($" ({svc})"); Console.WriteLine();
                                            }
                                        }
                                        catch { }
                                    }
                                }
                                finally { hostSem.Release(); }
                            }));
                        }
                        await Task.WhenAll(hostTasks);
                    }

                    // show IPv6 local addresses (no large IPv6 sweeps performed)
                    if (localV6.Count > 0)
                    {
                        Console.WriteLine("Local IPv6 addresses:");
                        foreach (var v6 in localV6) Console.WriteLine("  " + v6);
                        Console.WriteLine("IPv6 network scanning is not performed by default due to large address space. Use explicit targets for IPv6 hosts.");
                    }

                    await Task.CompletedTask; return;
                }

                // single-host scan: resolve to all address families and scan each address (IPv4 + IPv6)
                string hostSingle = targetArg;
                var argPorts = portsArg;
                int explicitPortSingle = -1;
                if (hostSingle.StartsWith("http://", StringComparison.OrdinalIgnoreCase) || hostSingle.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                {
                    try { var u = new Uri(hostSingle); hostSingle = u.Host; if (u.Port > 0) explicitPortSingle = u.Port; } catch { }
                }
                else if (hostSingle.IndexOf(':') > 0 && !hostSingle.Contains('/'))
                {
                    var sp = hostSingle.Split(':'); hostSingle = sp[0]; if (int.TryParse(sp[1], out var p)) explicitPortSingle = p;
                }

                Console.WriteLine($"Resolving: {hostSingle}...");
                var addrsSingle = await Dns.GetHostAddressesAsync(hostSingle);
                if (addrsSingle == null || addrsSingle.Length == 0) { Console.WriteLine("Could not resolve host"); await Task.CompletedTask; return; }
                Console.WriteLine($"Resolved addresses: {string.Join(',', addrsSingle.Select(a => a.ToString() + "(" + a.AddressFamily + ")"))}");

                // parse portsArg
                var portsSingle = new List<int>();
                foreach (var token in argPorts.Split(',', StringSplitOptions.RemoveEmptyEntries))
                {
                    var t = token.Trim();
                    if (t.Contains('-'))
                    {
                        var p = t.Split('-', 2);
                        if (int.TryParse(p[0], out var a) && int.TryParse(p[1], out var b)) { for (int i2 = Math.Min(a,b); i2 <= Math.Max(a,b); i2++) portsSingle.Add(i2); }
                    }
                    else if (int.TryParse(t, out var p)) portsSingle.Add(p);
                }
                if (explicitPortSingle > 0) { if (!portsSingle.Contains(explicitPortSingle)) portsSingle.Insert(0, explicitPortSingle); }
                portsSingle = portsSingle.Distinct().Where(p => p >= 1 && p <= 65535).OrderBy(p => p).ToList();
                if (portsSingle.Count == 0) { Console.WriteLine("No ports to scan."); await Task.CompletedTask; return; }

                var wellKnownSingle = new Dictionary<int,string> { [22] = "ssh", [80] = "http", [443] = "https", [3389] = "rdp", [3306] = "mysql", [8080] = "http-alt", [53] = "dns", [21] = "ftp", [25] = "smtp", [445] = "microsoft-ds" };

                // helper to detect private IPv4
                static bool IsPrivateIPv4(IPAddress ip)
                {
                    if (ip.AddressFamily != System.Net.Sockets.AddressFamily.InterNetwork) return false;
                    var b = ip.GetAddressBytes();
                    // 10.0.0.0/8
                    if (b[0] == 10) return true;
                    // 172.16.0.0/12
                    if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;
                    // 192.168.0.0/16
                    if (b[0] == 192 && b[1] == 168) return true;
                    // loopback
                    if (b[0] == 127) return true;
                    return false;
                }

                foreach (var addr in addrsSingle)
                {
                    try
                    {
                        // if target is public IPv4 or global IPv6 and external scanning not allowed, require explicit consent
                        bool isPublicIPv4 = addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork && !IsPrivateIPv4(addr);
                        bool isGlobalIPv6 = addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6 && !(addr.IsIPv6LinkLocal || addr.IsIPv6SiteLocal || addr.IsIPv6Multicast);
                        if ((isPublicIPv4 || isGlobalIPv6) && !allowExternal)
                        {
                            Console.WriteLine($"Address {addr} appears to be public. Scanning external hosts requires explicit permission and may be illegal without authorization.");
                            Console.Write("Type 'I have permission' to proceed with scanning this external address: ");
                            var consent = Console.ReadLine();
                            if (consent == null || !consent.Trim().Equals("I have permission", StringComparison.Ordinal)) { Console.WriteLine("Skipped external address: " + addr); continue; }
                        }

                        Console.WriteLine($"Scanning address {addr} ({addr.AddressFamily})...");
                        foreach (var port in portsSingle)
                        {
                            try
                            {
                                using var tc = new TcpClient(addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6 ? System.Net.Sockets.AddressFamily.InterNetworkV6 : System.Net.Sockets.AddressFamily.InterNetwork);
                                var connectTask = tc.ConnectAsync(addr, port);
                                var completed = await Task.WhenAny(connectTask, Task.Delay(700));
                                if (completed == connectTask && tc.Connected)
                                {
                                    Console.Write($"{addr} {port}: open"); if (wellKnownSingle.TryGetValue(port, out var svc)) Console.Write($" ({svc})"); Console.WriteLine();
                                    try
                                    {
                                        using var ns = tc.GetStream();
                                        ns.ReadTimeout = 500; ns.WriteTimeout = 500;
                                        if (port == 80 || port == 8080 || port == 8000)
                                        {
                                            var probe = Encoding.ASCII.GetBytes("HEAD / HTTP/1.0\r\nHost: " + hostSingle + "\r\n\r\n");
                                            await ns.WriteAsync(probe, 0, probe.Length);
                                        }
                                        var buf = new byte[512];
                                        var readTask = ns.ReadAsync(buf, 0, buf.Length);
                                        var rcomp = await Task.WhenAny(readTask, Task.Delay(500));
                                        if (rcomp == readTask && readTask.Result > 0)
                                        {
                                            var txt = Encoding.UTF8.GetString(buf, 0, readTask.Result);
                                            var firstLine = txt.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault() ?? "";
                                            Console.WriteLine("  banner: " + (firstLine.Length>200? firstLine.Substring(0,200)+"...": firstLine));
                                        }
                                    }
                                    catch { }
                                }
                                else
                                {
                                    Console.WriteLine($"{addr} {port}: closed");
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"{addr} {port}: error ({ex.Message})");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Address {addr} scan error: {ex.Message}");
                    }
                }
            }
            catch (Exception ex) { Console.WriteLine("scan error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // whoamiip - show public IP
        BuiltInCommands["whoamiip"] = async args =>
        {
            try
            {
                using var http = new HttpClient(); http.Timeout = TimeSpan.FromSeconds(5);
                try { var ip = await http.GetStringAsync("https://api.ipify.org"); Console.WriteLine("Public IP: " + ip.Trim()); }
                catch { var ip = await http.GetStringAsync("https://icanhazip.com"); Console.WriteLine("Public IP: " + ip.Trim()); }
            }
            catch (Exception ex) { Console.WriteLine("whoamiip error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // netstat - list listeners and established connections
        BuiltInCommands["netstat"] = async args =>
        {
            try
            {
                var props = IPGlobalProperties.GetIPGlobalProperties();
                var listeners = props.GetActiveTcpListeners();
                Console.WriteLine("TCP Listeners:"); foreach (var l in listeners) Console.WriteLine($"  {l}");
                var conns = props.GetActiveTcpConnections();
                Console.WriteLine("TCP Connections:"); foreach (var c in conns) Console.WriteLine($"  {c.LocalEndPoint} -> {c.RemoteEndPoint} ({c.State})");
            }
            catch (Exception ex) { Console.WriteLine("netstat error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // discover - simple local subnet ping sweep (limited range)
        BuiltInCommands["discover"] = async args =>
        {
            try
            {
                // find a local IPv4
                string local = null;
                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.OperationalStatus != OperationalStatus.Up) continue;
                    foreach (var ua in ni.GetIPProperties().UnicastAddresses)
                    {
                        if (ua.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork && !IPAddress.IsLoopback(ua.Address)) { local = ua.Address.ToString(); break; }
                    }
                    if (local != null) break;
                }
                if (local == null) { Console.WriteLine("No local IPv4 address found."); await Task.CompletedTask; return; }
                var parts = local.Split('.'); var prefix = string.Join('.', parts.Take(3)) + ".";
                int max = 32; if (args.Length > 0 && int.TryParse(args[0], out var m)) max = Math.Min(254, Math.Max(4, m));
                Console.WriteLine($"Pinging hosts {prefix}1-{prefix}{max} ...");
                var tasks = new List<Task>(); var up = new List<string>();
                var sem = new System.Threading.SemaphoreSlim(50);
                for (int i = 1; i <= max; i++)
                {
                    var ip = prefix + i;
                    await sem.WaitAsync();
                    tasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            using var p = new Ping(); var r = await p.SendPingAsync(ip, 300);
                            if (r.Status == IPStatus.Success) lock (up) { up.Add(ip); }
                        }
                        catch { }
                        finally { sem.Release(); }
                    }));
                }
                await Task.WhenAll(tasks);
                Console.WriteLine("Up hosts:"); foreach (var h in up) Console.WriteLine("  " + h);
            }
            catch (Exception ex) { Console.WriteLine("discover error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // Open a file or URL in the default application (cross-platform)
        BuiltInCommands["open"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: open <file-or-url>"); await Task.CompletedTask; return; }
            var target = args[0];
            try
            {
                var psi = new ProcessStartInfo { FileName = target, UseShellExecute = true };
                Process.Start(psi);
            }
            catch (Exception ex) { Console.WriteLine("open error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // Download a URL to the downloads folder: get <url> [filename]
        BuiltInCommands["get"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: get <url> [outName]"); await Task.CompletedTask; return; }
            try
            {
                var url = args[0];
                var outName = args.Length > 1 ? args[1] : Path.GetFileName(new Uri(url).LocalPath);
                if (string.IsNullOrEmpty(outName)) outName = "downloaded.file";
                var dl = Path.Combine(Directory.GetCurrentDirectory(), "downloads"); Directory.CreateDirectory(dl);
                var outPath = Path.Combine(dl, outName);
                using var http = new HttpClient();
                using var resp = await http.GetAsync(url);
                if (!resp.IsSuccessStatusCode) { Console.WriteLine($"Failed to download: {resp.StatusCode}"); await Task.CompletedTask; return; }
                var data = await resp.Content.ReadAsByteArrayAsync();
                await File.WriteAllBytesAsync(outPath, data);
                Console.WriteLine($"Saved to {outPath}");
            }
            catch (Exception ex) { Console.WriteLine("get error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // Print directory tree: tree [path] [depth]
        BuiltInCommands["tree"] = async args =>
        {
            var root = args.Length > 0 ? args[0] : CurrentDirectory;
            int maxDepth = args.Length > 1 && int.TryParse(args[1], out var d) ? d : int.MaxValue;
            if (!Path.IsPathRooted(root)) root = Path.GetFullPath(Path.Combine(CurrentDirectory, root));
            void Walk(string dir, int indent, int depth)
            {
                if (depth > maxDepth) return;
                try
                {
                    var name = Path.GetFileName(dir);
                    Console.WriteLine(new string(' ', indent) + (string.IsNullOrEmpty(name) ? dir : name));
                    foreach (var f in Directory.GetFiles(dir).OrderBy(f => f)) Console.WriteLine(new string(' ', indent + 2) + Path.GetFileName(f));
                    foreach (var d2 in Directory.GetDirectories(dir).OrderBy(d2 => d2)) Walk(d2, indent + 2, depth + 1);
                }
                catch (Exception ex) { Console.WriteLine(new string(' ', indent) + "(error: " + ex.Message + ")"); }
            }
            if (!Directory.Exists(root)) { Console.WriteLine("Directory not found: " + root); await Task.CompletedTask; return; }
            Walk(root, 0, 0);
            await Task.CompletedTask;
        };

        // findtext <pattern> [path]
        BuiltInCommands["findtext"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: findtext <pattern> [path]"); await Task.CompletedTask; return; }
            var pat = args[0];
            var root = args.Length > 1 ? args[1] : CurrentDirectory;
            if (!Path.IsPathRooted(root)) root = Path.GetFullPath(Path.Combine(CurrentDirectory, root));
            try
            {
                foreach (var f in Directory.EnumerateFiles(root, "*.*", SearchOption.AllDirectories))
                {
                    try
                    {
                        int ln = 0;
                        foreach (var line in File.ReadLines(f))
                        {
                            ln++;
                            if (line.IndexOf(pat, StringComparison.OrdinalIgnoreCase) >= 0)
                                Console.WriteLine($"{f}:{ln}: {line.Trim()}");
                        }
                    }
                    catch { }
                }
            }
            catch (Exception ex) { Console.WriteLine("findtext error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // serve [port] - tries to run python http.server in background; falls back to a minimal HttpListener if python not available
        BuiltInCommands["serve"] = async args =>
        {
            var port = 8000;
            if (args.Length > 0) int.TryParse(args[0], out port);
            var tried = false;
            try
            {
                // attempt to run python -m http.server
                var py = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "python" : "python3";
                var cmd = $"{py} -m http.server {port}";
                // run in background so shell remains usable
                _ = Task.Run(async () => await RunExternalAsync(cmd));
                Console.WriteLine($"Started server (if {py} available) on http://localhost:{port}/");
                tried = true;
            }
            catch { }
            if (!tried)
            {
                // fallback simple listener
                try
                {
                    var listener = new System.Net.HttpListener();
                    var prefix = $"http://localhost:{port}/";
                    listener.Prefixes.Add(prefix);
                    listener.Start();
                    Console.WriteLine($"Serving {CurrentDirectory} on {prefix} (press Ctrl+C to stop)");
                    _ = Task.Run(async () =>
                    {
                        while (listener.IsListening)
                        {
                            try
                            {
                                var ctx = await listener.GetContextAsync();
                                var reqPath = Uri.UnescapeDataString(ctx.Request.Url.AbsolutePath.TrimStart('/'));
                                var fsPath = string.IsNullOrEmpty(reqPath) ? Path.Combine(CurrentDirectory, "") : Path.Combine(CurrentDirectory, reqPath);
                                if (Directory.Exists(fsPath)) fsPath = Path.Combine(fsPath, "index.html");
                                if (File.Exists(fsPath))
                                {
                                    var data = await File.ReadAllBytesAsync(fsPath);
                                    ctx.Response.ContentLength64 = data.Length; await ctx.Response.OutputStream.WriteAsync(data, 0, data.Length);
                                }
                                else { ctx.Response.StatusCode = 404; var msg = Encoding.UTF8.GetBytes("Not found"); await ctx.Response.OutputStream.WriteAsync(msg, 0, msg.Length); }
                                ctx.Response.OutputStream.Close();
                            }
                            catch { }
                        }
                    });
                }
                catch (Exception ex) { Console.WriteLine("serve error: " + ex.Message); }
            }
            await Task.CompletedTask;
        };

        // mkfile <filename> <text...>  -- quick file create
        BuiltInCommands["mkfile"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: mkfile <filename> [text]"); await Task.CompletedTask; return; }
            var name = args[0]; if (!Path.IsPathRooted(name)) name = Path.Combine(CurrentDirectory, name);
            try { var content = args.Length > 1 ? string.Join(' ', args.Skip(1)) : string.Empty; await File.WriteAllTextAsync(name, content); Console.WriteLine($"Created {name}"); }
            catch (Exception ex) { Console.WriteLine("mkfile error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // calc <expression> - simple arithmetic evaluation
        BuiltInCommands["calc"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: calc <expression>"); await Task.CompletedTask; return; }
            var expr = string.Join(' ', args);
            try
            {
                // use DataTable Compute for quick eval
                var dt = new System.Data.DataTable();
                var result = dt.Compute(expr, null);
                Console.WriteLine(result?.ToString() ?? "");
            }
            catch (Exception ex) { Console.WriteLine("calc error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["clear"] = async args => { Console.Clear(); await Task.CompletedTask; };
        BuiltInCommands["cls"] = BuiltInCommands["clear"];

        BuiltInCommands["pwd"] = async args => { Console.WriteLine(CurrentDirectory); await Task.CompletedTask; };

        BuiltInCommands["cd"] = async args =>
        {
            try
            {
                if (args.Length == 0) CurrentDirectory = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
                else
                {
                    var target = args[0];
                    if (!Path.IsPathRooted(target)) target = Path.GetFullPath(Path.Combine(CurrentDirectory, target));
                    if (Directory.Exists(target)) CurrentDirectory = target; else Console.WriteLine("Directory not found: " + target);
                }
                Directory.SetCurrentDirectory(CurrentDirectory);
            }
            catch (Exception ex) { Console.WriteLine("cd error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["ls"] = async args =>
        {
            try
            {
                var entries = Directory.EnumerateFileSystemEntries(CurrentDirectory).OrderBy(n => n);
                foreach (var e in entries) Console.WriteLine(Path.GetFileName(e));
            }
            catch (Exception ex) { Console.WriteLine("ls error: " + ex.Message); }
            await Task.CompletedTask;
        };
        BuiltInCommands["dir"] = BuiltInCommands["ls"];

        BuiltInCommands["cat"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: cat <file>"); return; }
            var f = args[0]; if (!Path.IsPathRooted(f)) f = Path.Combine(CurrentDirectory, f);
            try { Console.WriteLine(await File.ReadAllTextAsync(f)); } catch (Exception ex) { Console.WriteLine("cat error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["mkdir"] = async args => { if (args.Length == 0) { Console.WriteLine("Usage: mkdir <dir>"); } else { var d = Path.Combine(CurrentDirectory, args[0]); Directory.CreateDirectory(d); } await Task.CompletedTask; };
        BuiltInCommands["rmdir"] = async args => { if (args.Length == 0) { Console.WriteLine("Usage: rmdir <dir>"); } else { var d = Path.Combine(CurrentDirectory, args[0]); try { Directory.Delete(d, true); } catch (Exception ex) { Console.WriteLine("rmdir error: " + ex.Message); } } await Task.CompletedTask; };

        BuiltInCommands["rm"] = async args => { if (args.Length == 0) { Console.WriteLine("Usage: rm <file>"); } else { var f = Path.Combine(CurrentDirectory, args[0]); try { File.Delete(f); } catch (Exception ex) { Console.WriteLine("rm error: " + ex.Message); } } await Task.CompletedTask; };

        BuiltInCommands["cp"] = async args => { if (args.Length < 2) { Console.WriteLine("Usage: cp <src> <dst>"); } else { var s = Path.Combine(CurrentDirectory, args[0]); var d = Path.Combine(CurrentDirectory, args[1]); try { File.Copy(s, d, true); } catch (Exception ex) { Console.WriteLine("cp error: " + ex.Message); } } await Task.CompletedTask; };
        BuiltInCommands["mv"] = async args => { if (args.Length < 2) { Console.WriteLine("Usage: mv <src> <dst>"); } else { var s = Path.Combine(CurrentDirectory, args[0]); var d = Path.Combine(CurrentDirectory, args[1]); try { File.Move(s, d); } catch (Exception ex) { Console.WriteLine("mv error: " + ex.Message); } } await Task.CompletedTask; };

        BuiltInCommands["echo"] = async args => { Console.WriteLine(string.Join(' ', args)); await Task.CompletedTask; };

        BuiltInCommands["whoami"] = async args => { Console.WriteLine(Environment.UserName); await Task.CompletedTask; };

        BuiltInCommands["uptime"] = async args => { Console.WriteLine(TimeSpan.FromMilliseconds(Environment.TickCount)); await Task.CompletedTask; };

        BuiltInCommands["ps"] = async args =>
        {
            foreach (var p in Process.GetProcesses().OrderBy(p => p.ProcessName)) Console.WriteLine($"{p.Id}\t{p.ProcessName}");
            await Task.CompletedTask;
        };

        BuiltInCommands["kill"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: kill <pid>"); await Task.CompletedTask; return; }
            if (int.TryParse(args[0], out var pid))
            {
                try { Process.GetProcessById(pid).Kill(); } catch (Exception ex) { Console.WriteLine("kill error: " + ex.Message); }
            }
            else Console.WriteLine("Invalid pid");
            await Task.CompletedTask;
        };

        // endalltasks: attempt to terminate all non-critical processes
        BuiltInCommands["endalltasks"] = async args =>
        {
            bool force = args.Length > 0 && (args[0].Equals("--force", StringComparison.OrdinalIgnoreCase) || args[0].Equals("-f", StringComparison.OrdinalIgnoreCase));
            if (!force)
            {
                Console.Write("WARNING: This will attempt to terminate most running processes (may require elevated rights). Continue? (y/N): ");
                var r = Console.ReadLine();
                if (string.IsNullOrEmpty(r) || !r.Trim().StartsWith("y", StringComparison.OrdinalIgnoreCase)) { Console.WriteLine("Aborted."); await Task.CompletedTask; return; }
            }

            var me = Process.GetCurrentProcess();
            var procs = Process.GetProcesses();
            foreach (var p in procs)
            {
                try
                {
                    // skip current process and critical/system process names
                    if (p.Id == me.Id) continue;
                    var name = p.ProcessName ?? string.Empty;
                    // common system processes to skip
                    var skip = new[] { "System", "Idle", "csrss", "wininit", "services", "lsass", "svchost", "Registry", "explorer" };
                    if (skip.Any(s => string.Equals(s, name, StringComparison.OrdinalIgnoreCase))) { Console.WriteLine($"Skipping protected process: {name} ({p.Id})"); continue; }

                    // try to close gracefully first
                    try { if (!p.HasExited) { p.CloseMainWindow(); await Task.Delay(200); } } catch { }
                    // then kill if still running
                    if (!p.HasExited)
                    {
                        try { p.Kill(true); Console.WriteLine($"Killed {name} ({p.Id})"); }
                        catch (Exception ex) { Console.WriteLine($"Failed to kill {name} ({p.Id}): {ex.Message}"); }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error processing process: {ex.Message}");
                }
            }

            Console.WriteLine("endalltasks completed (attempted).");
            await Task.CompletedTask;
        };

        // simple inline editor: 'write' or 'md' starts multi-line entry; press Enter twice to save
        Func<string[], Task> writeHandler = async args =>
        {
            try
            {
                string fileName;
                if (args.Length > 0)
                {
                    fileName = args[0];
                }
                else
                {
                    Console.Write("Filename (without ext): ");
                    fileName = Console.ReadLine();
                    if (fileName == null) { Console.WriteLine("Aborted."); return; }
                }
                if (string.IsNullOrWhiteSpace(fileName)) { Console.WriteLine("Invalid filename."); return; }
                if (!fileName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase)) fileName = fileName + ".txt";
                var outPath = fileName;
                if (!Path.IsPathRooted(outPath)) outPath = Path.Combine(CurrentDirectory, outPath);

                if (File.Exists(outPath))
                {
                    Console.Write($"File '{outPath}' exists. Overwrite? (y/N): ");
                    var ok = Console.ReadLine(); if (string.IsNullOrEmpty(ok) || !ok.Trim().StartsWith("y", StringComparison.OrdinalIgnoreCase)) { Console.WriteLine("Aborted."); return; }
                }

                Console.WriteLine("Enter text. Press Enter twice (blank line twice) to save and exit.");
                var lines = new List<string>();
                int blankStreak = 0;
                while (true)
                {
                    var line = Console.ReadLine();
                    if (line == null) break; // EOF
                    if (string.IsNullOrEmpty(line)) { blankStreak++; }
                    else { blankStreak = 0; }
                    if (blankStreak >= 2) break;
                    lines.Add(line);
                }

                // trim trailing blank lines that were used to signal exit
                while (lines.Count > 0 && string.IsNullOrEmpty(lines.Last())) lines.RemoveAt(lines.Count - 1);

                try { await File.WriteAllTextAsync(outPath, string.Join(Environment.NewLine, lines)); Console.WriteLine($"Saved to {outPath}"); }
                catch (Exception ex) { Console.WriteLine("Failed to save file: " + ex.Message); }
            }
            catch (Exception ex) { Console.WriteLine("write error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["write"] = writeHandler;
        BuiltInCommands["md"] = writeHandler;

        BuiltInCommands["ping"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: ping <host>"); await Task.CompletedTask; return; }
            try
            {
                using var p = new Ping(); var reply = await p.SendPingAsync(args[0], 2000);
                Console.WriteLine($"{reply.Address} bytes={reply.Buffer.Length} time={reply.RoundtripTime}ms status={reply.Status}");
            }
            catch (Exception ex) { Console.WriteLine("ping error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["search"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: search <pattern>"); await Task.CompletedTask; return; }
            try { foreach (var f in Directory.EnumerateFiles(CurrentDirectory, "*" + args[0] + "*", SearchOption.AllDirectories)) Console.WriteLine(f); }
            catch (Exception ex) { Console.WriteLine("search error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["zip"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: zip <sourceDir> <outZip>"); await Task.CompletedTask; return; }
            try { ZipFile.CreateFromDirectory(Path.Combine(CurrentDirectory, args[0]), Path.Combine(CurrentDirectory, args[1])); Console.WriteLine("zipped"); }
            catch (Exception ex) { Console.WriteLine("zip error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["unzip"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: unzip <zip> <outDir>"); await Task.CompletedTask; return; }
            try { ZipFile.ExtractToDirectory(Path.Combine(CurrentDirectory, args[0]), Path.Combine(CurrentDirectory, args[1])); Console.WriteLine("unzipped"); }
            catch (Exception ex) { Console.WriteLine("unzip error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["history"] = async args => { for (int i = 0; i < History.Count; i++) Console.WriteLine($"{i+1}: {History[i]}"); await Task.CompletedTask; };

        BuiltInCommands["showdownloads"] = async args => { var dl = Path.Combine(CurrentDirectory, "downloads"); if (Directory.Exists(dl)) foreach (var d in Directory.GetFileSystemEntries(dl)) Console.WriteLine(d); else Console.WriteLine("no downloads"); await Task.CompletedTask; };
        BuiltInCommands["showinstalled"] = async args => { var ins = Path.Combine(CurrentDirectory, "installed"); if (Directory.Exists(ins)) foreach (var d in Directory.GetFileSystemEntries(ins)) Console.WriteLine(d); else Console.WriteLine("no installed"); await Task.CompletedTask; };

        // Additional safe "legal hacks" utilities
        BuiltInCommands["b64"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: b64 <encode|decode> <text>"); await Task.CompletedTask; return; }
            try
            {
                var mode = args[0].ToLowerInvariant();
                var text = string.Join(' ', args.Skip(1));
                if (mode == "encode")
                {
                    var bytes = Encoding.UTF8.GetBytes(text);
                    Console.WriteLine(Convert.ToBase64String(bytes));
                }
                else if (mode == "decode")
                {
                    try { var bytes = Convert.FromBase64String(text); Console.WriteLine(Encoding.UTF8.GetString(bytes)); }
                    catch { Console.WriteLine("Invalid base64 string"); }
                }
                else Console.WriteLine("Usage: b64 <encode|decode> <text>");
            }
            catch (Exception ex) { Console.WriteLine("b64 error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["jsonfmt"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: jsonfmt <json-or-file-path>"); await Task.CompletedTask; return; }
            try
            {
                var input = string.Join(' ', args);
                string raw;
                if (File.Exists(input)) raw = await File.ReadAllTextAsync(input);
                else raw = input;
                using var doc = JsonDocument.Parse(raw);
                var options = new JsonSerializerOptions { WriteIndented = true };
                var obj = JsonSerializer.Deserialize<object>(raw);
                var pretty = JsonSerializer.Serialize(obj, options);
                Console.WriteLine(pretty);
            }
            catch (Exception ex) { Console.WriteLine("jsonfmt error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["subdomains"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: subdomains <domain>"); await Task.CompletedTask; return; }
            var host = args[0].Trim();
            if (host.EndsWith(".")) host = host.TrimEnd('.');
            var prefixes = new[] { "www", "api", "dev", "staging", "mail", "ftp", "admin", "beta", "test", "m", "blog", "shop" };
            foreach (var p in prefixes)
            {
                var fq = p + "." + host;
                try
                {
                    var addrs = await Dns.GetHostAddressesAsync(fq);
                    if (addrs != null && addrs.Length > 0) Console.WriteLine($"{fq} -> {string.Join(',', addrs)}");
                }
                catch { }
            }
            await Task.CompletedTask;
        };

        BuiltInCommands["checkports"] = async args =>
        {
            if (args.Length == 0) { Console.WriteLine("Usage: checkports <host> [ports]"); await Task.CompletedTask; return; }
            var host = args[0];
            var portsArg = args.Length > 1 ? args[1] : "22,80,443";
            var ports = new List<int>();
            try
            {
                foreach (var token in portsArg.Split(',', StringSplitOptions.RemoveEmptyEntries))
                {
                    if (token.Contains('-'))
                    {
                        var parts = token.Split('-', 2); if (int.TryParse(parts[0], out var a) && int.TryParse(parts[1], out var b)) { for (int i = Math.Min(a,b); i <= Math.Max(a,b); i++) ports.Add(i); }
                    }
                    else if (int.TryParse(token, out var p)) ports.Add(p);
                }
                if (ports.Count == 0) { Console.WriteLine("No valid ports specified."); await Task.CompletedTask; return; }
                foreach (var p in ports.Distinct().OrderBy(x => x))
                {
                    try
                    {
                        using var tc = new TcpClient();
                        var task = tc.ConnectAsync(host, p);
                        var completed = await Task.WhenAny(task, Task.Delay(500));
                        if (completed == task && tc.Connected) Console.WriteLine($"{p}: open"); else Console.WriteLine($"{p}: closed");
                    }
                    catch (Exception ex) { Console.WriteLine($"{p}: error ({ex.Message})"); }
                }
            }
            catch (Exception ex) { Console.WriteLine("checkports error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // more small utilities
        BuiltInCommands["env"] = async args =>
        {
            try
            {
                if (args.Length == 0)
                {
                    foreach (System.Collections.DictionaryEntry kv in Environment.GetEnvironmentVariables()) Console.WriteLine($"{kv.Key}={kv.Value}");
                }
                else
                {
                    var v = Environment.GetEnvironmentVariable(args[0]);
                    Console.WriteLine(v ?? "(not set)");
                }
            }
            catch (Exception ex) { Console.WriteLine("env error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["epoch"] = async args =>
        {
            try
            {
                if (args.Length == 0) { var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); Console.WriteLine(now); await Task.CompletedTask; return; }
                if (args[0].Equals("to", StringComparison.OrdinalIgnoreCase) && args.Length > 1 && long.TryParse(args[1], out var secs))
                {
                    var dt = DateTimeOffset.FromUnixTimeSeconds(secs).ToLocalTime(); Console.WriteLine(dt.ToString()); await Task.CompletedTask; return;
                }
                if (args[0].Equals("from", StringComparison.OrdinalIgnoreCase) && args.Length > 1 && DateTimeOffset.TryParse(string.Join(' ', args.Skip(1)), out var dto))
                {
                    Console.WriteLine(dto.ToUnixTimeSeconds()); await Task.CompletedTask; return;
                }
                Console.WriteLine("Usage: epoch [to <seconds>|from <date>] or no args to print now");
            }
            catch (Exception ex) { Console.WriteLine("epoch error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["randstr"] = async args =>
        {
            try
            {
                int len = 24; if (args.Length > 0) int.TryParse(args[0], out len);
                if (len < 1) len = 1; if (len > 4096) len = 4096;
                var buf = new byte[len]; using var rng = RandomNumberGenerator.Create(); rng.GetBytes(buf);
                // base64url-safe
                var s = Convert.ToBase64String(buf).TrimEnd('='); s = s.Replace('+', '-').Replace('/', '_');
                Console.WriteLine(s.Substring(0, Math.Min(s.Length, len)));
            }
            catch (Exception ex) { Console.WriteLine("randstr error: " + ex.Message); }
            await Task.CompletedTask;
        };

        BuiltInCommands["extract"] = async args =>
        {
            if (args.Length < 2) { Console.WriteLine("Usage: extract <zip> <outDir>"); await Task.CompletedTask; return; }
            try
            {
                var zip = args[0]; var outd = args[1]; if (!Path.IsPathRooted(zip)) zip = Path.Combine(CurrentDirectory, zip); if (!Path.IsPathRooted(outd)) outd = Path.Combine(CurrentDirectory, outd);
                if (!File.Exists(zip)) { Console.WriteLine("Zip not found: " + zip); await Task.CompletedTask; return; }
                Directory.CreateDirectory(outd);
                ZipFile.ExtractToDirectory(zip, outd);
                Console.WriteLine("Extracted to " + outd);
            }
            catch (Exception ex) { Console.WriteLine("extract error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // hacker - fun Matrix-style green text simulation
        BuiltInCommands["hacker"] = async args =>
        {
            try
            {
                // determine seconds to run: prefer first arg; otherwise prompt the user
                int seconds = 5;
                if (args.Length > 0)
                {
                    int.TryParse(args[0], out seconds);
                }
                else
                {
                    Console.Write("Enter duration in seconds (default 5): ");
                    var input = Console.ReadLine();
                    if (!string.IsNullOrWhiteSpace(input) && int.TryParse(input.Trim(), out var parsed)) seconds = parsed;
                }
                if (seconds <= 0) seconds = 5;

                var chars = "abcdefghijklmnopqrstuvwxyz0123456789@#$%&*()-_=+<>?/\\|";
                var rand = new Random();
                var sw = Stopwatch.StartNew();
                var prevColor = Console.ForegroundColor;
                try
                {
                    Console.Clear();
                    while (sw.ElapsedMilliseconds < seconds * 1000)
                    {
                        int width = 80;
                        int height = 24;
                        try { width = Math.Max(10, Console.WindowWidth - 1); height = Math.Max(4, Console.WindowHeight); } catch { }

                        // print a small random block of lines
                        int lines = rand.Next(1, Math.Max(2, Math.Min(6, height / 4)));
                        for (int i = 0; i < lines; i++)
                        {
                            var sb = new StringBuilder();
                            int len = rand.Next(10, Math.Max(10, width));
                            for (int j = 0; j < len; j++) sb.Append(chars[rand.Next(chars.Length)]);
                            Console.ForegroundColor = ConsoleColor.Green;
                            Console.WriteLine(sb.ToString());
                        }

                        // small pause to create falling effect
                        await Task.Delay(rand.Next(30, 120));
                    }
                }
                finally
                {
                    Console.ForegroundColor = prevColor;
                    Console.WriteLine();
                    Console.WriteLine("[hacker] simulation complete.");
                }
            }
            catch (Exception ex) { Console.WriteLine("hacker error: " + ex.Message); }
            await Task.CompletedTask;
        };

        // passthrough aliases removed
    }
    static async Task<int> Main()
    {
        // Stylized banner and prompt for 'ter v1.0'
        PrintBanner();
        Console.Title = "ter v1.0";
        Console.WriteLine("ter v1.0 - Interactive shell runner. Type 'exit' to quit.");
        var isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);

        var downloadsDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads");
        Directory.CreateDirectory(downloadsDir);

        // initialize built-ins once so aliases and internal commands work
        CurrentDirectory = Directory.GetCurrentDirectory();
        InitializeBuiltIns();

        // Auto-download common repos if missing
        await TryAutoDownload("jorangeef/sudo-prompt");
        await TryAutoDownload("ahmed-alaa-eldine/fix-termux");

        while (true)
        {
            WritePrompt();
            var input = Console.ReadLine();
            if (input == null) break;
            if (input.Trim().Equals("exit", StringComparison.OrdinalIgnoreCase)) break;

            if (string.IsNullOrWhiteSpace(input)) continue;

            // (google: search shortcut removed)

            // record history
            History.Add(input);

            // quick built-in dispatch
            // special-case: allow shorthand "scan in" to scan the local host
            if (input.TrimStart().StartsWith("scan in", StringComparison.OrdinalIgnoreCase))
            {
                var rest = input.Trim().Length > "scan in".Length ? input.Trim().Substring("scan in".Length).Trim() : string.Empty;
                var scanArgs = string.IsNullOrEmpty(rest) ? new string[] { "localhost" } : new string[] { "localhost", rest };
                if (BuiltInCommands.TryGetValue("scan", out var scanHandler))
                {
                    try { await scanHandler(scanArgs); } catch (Exception ex) { Console.WriteLine("Command error: " + ex.Message); }
                    continue;
                }
            }

            var toks = input.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (toks.Length > 0)
            {
                var cmd = toks[0]; var args = toks.Skip(1).ToArray();
                if (BuiltInCommands.TryGetValue(cmd, out var handler))
                {
                    try { await handler(args); } catch (Exception ex) { Console.WriteLine("Command error: " + ex.Message); }
                    continue;
                }
            }

            try
            {
                if (input.TrimStart().StartsWith("download ", StringComparison.OrdinalIgnoreCase))
                {
                    var arg = input.Substring(input.IndexOf(' ') + 1).Trim();
                    if (string.IsNullOrEmpty(arg)) { Console.WriteLine("Usage: download <owner/repo|repo-name|url>"); continue; }
                    if (!arg.Contains("/") && !arg.StartsWith("http://") && !arg.StartsWith("https://")) arg = "jorangeef/" + arg;
                    await DownloadGitHubRepoAsync(arg, retryUntilSuccess: true);
                    continue;
                }

                if (input.TrimStart().StartsWith("fetchfile ", StringComparison.OrdinalIgnoreCase))
                {
                    var tokens = input.Substring(input.IndexOf(' ') + 1).Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
                    if (tokens.Length < 2) { Console.WriteLine("Usage: fetchfile <owner/repo> <path> [--force]"); continue; }
                    var repo = tokens[0]; var path = tokens[1]; bool force = path.EndsWith("--force", StringComparison.OrdinalIgnoreCase) || path.EndsWith("-f", StringComparison.OrdinalIgnoreCase);
                    if (force) path = path.Substring(0, path.LastIndexOf(' ')).TrimEnd();
                    if (!repo.Contains('/')) repo = "jorangeef/" + repo;
                    await DownloadFileFromGitHubAsync(repo, path, retryUntilSuccess: true, force: force);
                    continue;
                }

                if (input.TrimStart().StartsWith("install ", StringComparison.OrdinalIgnoreCase) || input.TrimStart().StartsWith("nstall ", StringComparison.OrdinalIgnoreCase))
                {
                    var body = input.Substring(input.IndexOf(' ') + 1).Trim();
                    var parts = body.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                    if (parts.Length == 0) { Console.WriteLine("Usage: install <owner/repo|repo-name|url> [targetName] [--force]"); continue; }
                    bool force = parts[^1].Equals("--force", StringComparison.OrdinalIgnoreCase) || parts[^1].Equals("-f", StringComparison.OrdinalIgnoreCase);
                    if (force) Array.Resize(ref parts, parts.Length - 1);
                    var repoArg = parts[0]; var targetName = parts.Length >= 2 ? parts[1] : null;
                    // tolerate user typing `https;github/...` by normalizing to `https://github/...`
                    if (repoArg.Contains(";") && (repoArg.StartsWith("http", StringComparison.OrdinalIgnoreCase)))
                        repoArg = repoArg.Replace(";", "://");

                    // If a full URL was provided, extract owner/repo and optional targetName from the path
                    if (repoArg.StartsWith("http://", StringComparison.OrdinalIgnoreCase) || repoArg.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                    {
                        try
                        {
                            var uri = new Uri(repoArg);
                            var segs = uri.AbsolutePath.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
                            if (segs.Length >= 2)
                            {
                                // owner/repo
                                var ownerRepo = segs[0] + "/" + segs[1];
                                // if the URL contains an extra segment (e.g. /owner/repo/command), use it as default targetName
                                if (targetName == null && segs.Length >= 3)
                                    targetName = segs[2];
                                repoArg = ownerRepo;
                            }
                        }
                        catch { }
                    }

                    if (!repoArg.Contains('/') && !repoArg.StartsWith("http://") && !repoArg.StartsWith("https://")) repoArg = "jorangeef/" + repoArg;
                    await DownloadGitHubRepoAsync(repoArg, retryUntilSuccess: true);
                    await InstallRepoAsync(repoArg, force, targetName);
                    continue;
                }

                if (input.TrimStart().StartsWith("website ", StringComparison.OrdinalIgnoreCase))
                {
                    var parts = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                    string link = null, file = null;
                    for (int i = 1; i < parts.Length; i++)
                    {
                        if (parts[i].Equals("-link", StringComparison.OrdinalIgnoreCase) && i + 1 < parts.Length) link = parts[++i];
                        else if (parts[i].Equals("-file", StringComparison.OrdinalIgnoreCase) && i + 1 < parts.Length) file = parts[++i];
                    }
                    if (string.IsNullOrEmpty(link) || string.IsNullOrEmpty(file)) { Console.WriteLine("Usage: website -link <url> -file <path>"); continue; }
                    Console.WriteLine("Downloading repository 'don-no7/hack-sql' for inspection...");
                    await DownloadGitHubRepoAsync("don-no7/hack-sql", retryUntilSuccess: true);
                    var dlDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads");
                    var candidates = Directory.GetDirectories(dlDir, "don-no7-hack-sql-*");
                    if (candidates.Length == 0) { Console.WriteLine("Could not find extracted repo"); continue; }
                    var repoDir = candidates[0]; var targetPath = Path.Combine(repoDir, file);
                    if (!File.Exists(targetPath)) { Console.WriteLine("File not found in repo: " + file); continue; }
                    Console.WriteLine("--- Begin file content (read-only) ---"); Console.WriteLine(await File.ReadAllTextAsync(targetPath)); Console.WriteLine("--- End file content ---");
                    Console.Write("Do you own the target website and want to verify ownership for authorized testing? (y/n): ");
                    var yn = Console.ReadLine(); if (!string.IsNullOrEmpty(yn) && yn.Trim().StartsWith("y", StringComparison.OrdinalIgnoreCase)) { var verified = await VerifyOwnershipAsync(link); Console.WriteLine(verified ? "Ownership verified." : "Ownership verification failed."); }
                    continue;
                }

                // fallback: run shell command via helper
                await RunExternalAsync(input);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("Error: " + ex.Message);
            }
        }

        return 0;
    }

    // Helpers
    static async Task TryAutoDownload(string ownerRepo)
    {
        var downloadsDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads");
        var mainDir = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-main");
        var masterDir = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-master");
        if (!Directory.Exists(mainDir) && !Directory.Exists(masterDir))
        {
            Console.WriteLine($"{ownerRepo} not found in downloads; attempting to download...");
            try { await DownloadGitHubRepoAsync(ownerRepo); } catch (Exception ex) { Console.WriteLine("Auto-download failed: " + ex.Message); }
        }
    }

    static async Task DownloadGitHubRepoAsync(string repoSpecifier, bool retryUntilSuccess = false)
    {
        bool done = false;
        while (!done)
        {
            string ownerRepo = repoSpecifier;
            if (repoSpecifier.StartsWith("http://") || repoSpecifier.StartsWith("https://"))
            {
                try { var uri = new Uri(repoSpecifier); var parts = uri.AbsolutePath.Trim('/').Split('/'); if (parts.Length >= 2) ownerRepo = parts[0] + "/" + parts[1]; } catch { }
            }

            var defaultBranch = await DetermineDefaultBranchAsync(ownerRepo);
            var candidates = defaultBranch != null ? new[] { defaultBranch, "main", "master" } : new[] { "main", "master" };
            var baseUrl = $"https://github.com/{ownerRepo}/archive/refs/heads/";
            using var http = new HttpClient();

            var downloadsDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads"); Directory.CreateDirectory(downloadsDir);
            foreach (var branch in candidates)
            {
                var url = baseUrl + branch + ".zip";
                Console.WriteLine($"Attempting to download {url}...");
                try
                {
                    using var resp = await http.GetAsync(url);
                    if (!resp.IsSuccessStatusCode) { Console.WriteLine($"Failed to download branch '{branch}': {resp.StatusCode}"); continue; }
                    var fileName = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-" + branch + ".zip");
                    using (var fs = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None)) { await resp.Content.CopyToAsync(fs); }
                    var extractDir = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-" + branch);
                    if (Directory.Exists(extractDir)) { try { Directory.Delete(extractDir, true); } catch { } }
                    ZipFile.ExtractToDirectory(fileName, extractDir);
                    Console.WriteLine($"Downloaded and extracted to {extractDir}");
                    if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) { try { using var p = Process.Start(new ProcessStartInfo { FileName = "/bin/chmod", Arguments = $"-R +x \"{extractDir}\"", UseShellExecute = false, CreateNoWindow = true }); await p.WaitForExitAsync(); } catch { } }
                    done = true; break;
                }
                catch (Exception ex) { Console.WriteLine($"Error downloading {url}: {ex.Message}"); }
            }

            if (!done)
            {
                Console.WriteLine("Could not download repository. Ensure owner/repo is correct.");
                if (!retryUntilSuccess) break;
                Console.WriteLine("Retrying in 5s..."); await Task.Delay(5000);
            }
        }
    }

    static async Task<string> DetermineDefaultBranchAsync(string ownerRepo)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(ownerRepo)) return null;
            var parts = ownerRepo.Split('/'); if (parts.Length < 2) return null; var owner = parts[0]; var repo = parts[1];
            using var http = new HttpClient(); http.DefaultRequestHeaders.UserAgent.ParseAdd("ConsoleApp2/1.0"); http.Timeout = TimeSpan.FromSeconds(10);
            var apiUrl = $"https://api.github.com/repos/{owner}/{repo}";
            using var resp = await http.GetAsync(apiUrl); if (!resp.IsSuccessStatusCode) return null; using var stream = await resp.Content.ReadAsStreamAsync(); using var doc = await JsonDocument.ParseAsync(stream);
            if (doc.RootElement.TryGetProperty("default_branch", out var prop)) return prop.GetString(); return null;
        }
        catch { return null; }
    }

    static async Task DownloadFileFromGitHubAsync(string repoSpecifier, string pathInRepo, bool retryUntilSuccess = false, bool force = false)
    {
        string ownerRepo = repoSpecifier; if (repoSpecifier.StartsWith("http://") || repoSpecifier.StartsWith("https://")) { try { var uri = new Uri(repoSpecifier); var parts = uri.AbsolutePath.Trim('/').Split('/'); if (parts.Length >= 2) ownerRepo = parts[0] + "/" + parts[1]; } catch { } }
        var defaultBranch = await DetermineDefaultBranchAsync(ownerRepo); var branches = defaultBranch != null ? new[] { defaultBranch, "main", "master" } : new[] { "main", "master" };
        using var http = new HttpClient();
        while (true)
        {
            foreach (var branch in branches)
            {
                var rawUrl = $"https://raw.githubusercontent.com/{ownerRepo}/{branch}/{pathInRepo}";
                Console.WriteLine($"Attempting to fetch {rawUrl}...");
                try
                {
                    using var resp = await http.GetAsync(rawUrl);
                    if (!resp.IsSuccessStatusCode) { Console.WriteLine($"Failed to fetch from branch {branch}: {resp.StatusCode}"); continue; }
                    var content = await resp.Content.ReadAsByteArrayAsync(); var downloadsDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads"); Directory.CreateDirectory(downloadsDir);
                    var safeName = ownerRepo.Replace('/', '-') + "-" + branch + "-" + Path.GetFileName(pathInRepo); var outFile = Path.Combine(downloadsDir, safeName);
                    if (File.Exists(outFile) && !force) { Console.WriteLine($"File already exists: {outFile}. Use --force to overwrite."); return; }
                    await File.WriteAllBytesAsync(outFile, content); Console.WriteLine($"Saved to {outFile}"); return;
                }
                catch (Exception ex) { Console.WriteLine($"Error fetching {rawUrl}: {ex.Message}"); }
            }
            if (!retryUntilSuccess) { Console.WriteLine("Could not fetch file from any known branch."); return; }
            Console.WriteLine("Retrying in 5s... (Ctrl+C to abort)"); await Task.Delay(5000);
        }
    }

    // Ownership verification helper
    static async Task<bool> VerifyOwnershipAsync(string siteUrl)
    {
        if (string.IsNullOrWhiteSpace(siteUrl)) return false; if (!siteUrl.StartsWith("http://") && !siteUrl.StartsWith("https://")) siteUrl = "https://" + siteUrl;
        var token = Guid.NewGuid().ToString(); var fileName = $"verify-{token}.txt"; var verifyUrl = siteUrl.TrimEnd('/') + "/.well-known/" + fileName;
        Console.WriteLine("To verify ownership, create a file at: " + verifyUrl); Console.WriteLine("Token: " + token); Console.WriteLine("Press Enter when ready..."); Console.ReadLine();
        using var http = new HttpClient(); http.Timeout = TimeSpan.FromSeconds(10);
        try { var resp = await http.GetAsync(verifyUrl); if (!resp.IsSuccessStatusCode) return false; var text = await resp.Content.ReadAsStringAsync(); return text != null && text.Trim() == token; } catch { return false; }
    }

    static async Task InstallRepoAsync(string repoSpecifier, bool force, string targetName = null)
    {
        string ownerRepo = repoSpecifier; if (repoSpecifier.StartsWith("http://") || repoSpecifier.StartsWith("https://")) { try { var uri = new Uri(repoSpecifier); var parts = uri.AbsolutePath.Trim('/').Split('/'); if (parts.Length >= 2) ownerRepo = parts[0] + "/" + parts[1]; } catch { } }
        var downloadsDir = Path.Combine(Directory.GetCurrentDirectory(), "downloads"); var mainDir = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-main"); var masterDir = Path.Combine(downloadsDir, ownerRepo.Replace('/', '-') + "-master"); string repoDir = null; if (Directory.Exists(mainDir)) repoDir = mainDir; else if (Directory.Exists(masterDir)) repoDir = masterDir; else { Console.WriteLine("Repository not found in downloads after download step."); return; }
        var installRoot = Path.Combine(Directory.GetCurrentDirectory(), "installed"); Directory.CreateDirectory(installRoot); var installName = targetName ?? ownerRepo.Split('/')[1]; var installDir = Path.Combine(installRoot, installName);
        if (Directory.Exists(installDir)) { if (!force) { Console.WriteLine($"Install target {installDir} already exists. Use --force to overwrite."); return; } try { Directory.Delete(installDir, true); } catch { } }
        try { CopyDirectory(repoDir, installDir); } catch (Exception ex) { Console.WriteLine("Failed to copy files: " + ex.Message); return; }
        Console.WriteLine("Install complete."); var pkg = Path.Combine(installDir, "package.json"); if (File.Exists(pkg) && !RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) Console.WriteLine("Detected package.json. To install dependencies run: (cd " + installDir + " && npm install)");
    }

    static void CopyDirectory(string sourceDir, string destDir)
    {
        Directory.CreateDirectory(destDir);
        foreach (var file in Directory.GetFiles(sourceDir)) File.Copy(file, Path.Combine(destDir, Path.GetFileName(file)), true);
        foreach (var dir in Directory.GetDirectories(sourceDir)) CopyDirectory(dir, Path.Combine(destDir, Path.GetFileName(dir)));
    }

    static void PrintBanner()
    {
        // Minimal ASCII banner inspired by Kali style
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine("|   _______    |");
        Console.ForegroundColor = ConsoleColor.Blue;
        Console.WriteLine("|  |__   __|   |");
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("|     | |      |");
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine("|     | |      |");
        Console.ForegroundColor = ConsoleColor.Magenta;
        Console.WriteLine("|     | |      |");
        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine("|     |_|      |");
        Console.ResetColor();
        Console.WriteLine();
        // product name and version
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine("ter v1.0");
        Console.WriteLine("interactive shell - type 'exit' to quit");
        Console.ResetColor();
        Console.WriteLine();
    }

    static void WritePrompt()
    {
        // Stylized multi-line prompt similar to: [user@host:~]\n$ 
        var user = Environment.UserName;
        var host = "ter";

        // opening bracket and username
        Console.ForegroundColor = ConsoleColor.Green;
        Console.Write("| [");

        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.Write(user);

        // separator + host
        Console.ForegroundColor = ConsoleColor.Blue;
        Console.Write("/" + host);

        // trailing :~] in green
        Console.ForegroundColor = ConsoleColor.Blue;
        Console.Write(":~]");

        // newline and prompt symbol on its own line
        Console.WriteLine();
        Console.ForegroundColor = ConsoleColor.Green;
        Console.Write("|__ ");
        Console.ResetColor();
    }
}
